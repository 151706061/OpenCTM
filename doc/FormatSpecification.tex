%-------------------------------------------------------------------------------
% Document: OpenCTM Format Specification
% Author:   Marcus Geelnard
% Compile:  pdflatex FormatSpecification.tex
%-------------------------------------------------------------------------------
% Note: You need a LaTeX environment to build this document as PDF. The
% recommended way is to install TeX Live (http://www.tug.org/texlive/) and
% a decent LaTeX editor (e.g. texmaker, LEd, etc).
%
% Ubuntu:   sudo apt-get install texlive-full
% Mac OS X: http://www.tug.org/mactex/  (MacTeX.mpkg.zip)
%
% To build the PDF document, run pdflatex twice on this .tex file (in order to
% correctly build the TOC).
%-------------------------------------------------------------------------------

% Use the OpenCTM TeX style
\input{openctm-tex.sty}

% Document properties
\author{Marcus Geelnard}
\title{OpenCTM Format Specification}

% Document contents
\begin{document}

%--[ Title page ]---------------------------------------------------------------

\begin{titlepage}
\begin{center}
~
\vspace{5cm}

\includegraphics[width=10.0cm]{logo.pdf}
\vspace{0.4cm}

{\large File format version 5}

\vspace{1.0cm}

{\Large Format Specification}
\vspace{1.5cm}

Copyright \copyright \ 2009 Marcus Geelnard
\end{center}
\end{titlepage}


%--[ Table of contents ]--------------------------------------------------------

\tableofcontents


%-------------------------------------------------------------------------------

\chapter{Overview}
This document describes version 5 of the OpenCTM file format.

\section{File structure}
The structure of an OpenCTM file is as follows:

[Header]\newline
[Body data]

Each part of the file is described in the following chapters.

\section{Data formats}
All integer fields are stored in 32-bit little endian format (least significant
byte first).

All floating point fields are stored in 32-bit binary IEEE 754 format (little
endian).

All strings are stored as a 32-bit integer string length (number of bytes)
followed by a UTF-8 format string (there is no zero termination and no BOM).

\section{Packed data}
Some portions of the file are be packed by the lossless LZMA entropy coder,
and are encoded as follows:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} & \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Packed size (number of bytes, $p$).\\ \hline
4 & - & LZMA specific props (five bytes, required by the LZMA decoder).\\ \hline
9 & - & LZMA packed stream ($p$ bytes long).\\ \hline
\end{tabular}

The length of the unpacked data is always known from the context (e.g. the
triangle count uniquely defines the number of bytes required for the
uncompressed triangle indices array).

\subsection{Element interleaving}
Packed data may or may not use element level interleaving, meaning that the
data values are rearranged at the element level. For instance, in a data array
with three elements per value (stride = 3), $x$, $y$ and $z$, the elements are
rearranged as follows:

\begin{center}
$x_1,y_1,z_1,x_2,y_2,z_2,\ldots,x_N,y_N,z_N \Rightarrow 
x_1,x_2,\ldots,x_N,y_1,y_2,\ldots,y_N,z_1,z_2,\ldots,z_N$
\end{center}

When decompressing an array that uses element interleaving, the process is
reversed.

\subsection{Byte interleaving}
All packed data arrays use byte level interleaving, meaning that data values
are rearranged at the byte level. For instance, in an integer array, where each
element consists of four bytes: $a$, $b$, $c$ and $d$, the bytes are rearranged
as follows:

\begin{center}
$a_1,b_1,c_1,d_1,a_2,b_2,c_2,d_2,\ldots,a_N,b_N,c_N,d_N \Rightarrow 
a_1,a_2,\ldots,a_N,b_1,b_2,\ldots,b_N,c_1,c_2,\ldots,c_N,d_1,d_2,\ldots,d_N$
\end{center}

When decompressing an array that uses byte interleaving, the process is
reversed.

\subsection{Signed magnitude representation}
Packed integer arrays may or may not use signed magnitude representation.

A signed magnitude value, $x'$, is converted to a two's complement value,
$x$, with the following method:

$x = \left\{\begin{array}{ll}
x'\; shr\; 1 & x'_0 = 0 \\
-((x'+1)\; shr\; 1) & x'_0 = 1
\end{array} \right.$

...where $x'_0$ is the least significant bit of $x'$.


%-------------------------------------------------------------------------------

\chapter{Header}
The file must start with a header, which looks as follows:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Magic identifier (0x4d54434f, or "OCTM" when read as ASCII).\\ \hline
4 & Integer & File format version (0x00000005 = version 5).\\ \hline
8 & Integer & Compression method, which must be one of the following:\\
 & & 0x00574152 - Use the RAW compression method.\\
 & & 0x0031474d - Use the MG1 compression method.\\
 & & 0x0032474d - Use the MG2 compression method.\\ \hline
12 & Integer & Vertex count.\\ \hline
16 & Integer & Triangle count.\\ \hline
20 & Integer & UV map count.\\ \hline
24 & Integer & Attribute map count.\\ \hline
28 & Integer & Boolean flags, or:ed together:\\
 & & 0x00000001 - The file contains per-vertex normals.\\ \hline
32 & String & File comment ($p$ bytes long string).\\ \hline
\end{tabular}

The length of the file header is $36+p$ bytes, where $p$ is the length of the
comment string.


%-------------------------------------------------------------------------------

\chapter{Body data}
The body data follows immediately after the file header. Its file offset is
dictated by the length of the file header.

The format of the body data is specific for each compression method, which is
defined by the "Compression method" field in the header.

The body data contains the vertex, index, normal, UV map and attribute map
data, usually in a compressed form.


\section{RAW}
The layout of the body data for the RAW compression method is:

[Indices]\newline
[Vertices]\newline
[Normals]\newline
[UV Map 0]\newline
[UV Map 1]\newline
...\newline
[UV Map N]\newline
[Attribute Map 0]\newline
[Attribute Map 1]\newline
...\newline
[Attribute Map M]

\subsection{Indices}
The indices are stored as an integer identifier, 0x58444e49 ("INDX"), followed
by all the triangle indices. Each index is an unsigned integer value. There are
three indices per triangle, and the number of triangles is given by the
"Triangle count" field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x58444e49, or "INDX" when read as ASCII).\\ \hline
4 & Integer & Vertex index for the 1st corner of the 1st triangle.\\ \hline
8 & Integer & Vertex index for the 2nd corner of the 1st triangle.\\ \hline
12 & Integer & Vertex index for the 3rd corner of the 1st triangle.\\ \hline
16 & Integer & Vertex index for the 1st corner of the 2nd triangle.\\ \hline
... & & \\ \hline
\end{tabular}

The length of the indices section is $4(1+3N)$ bytes, where $N$ is the triangle
count.

\subsection{Vertices}
The vertices are stored as an integer identifier, 0x54524556 ("VERT"), followed
by all the vertex coordinates. Each vertex coordinate is stored as three
floating point values ($x,y,z$), and the number of vertices is given by the
"Vertex count" field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x54524556, or "VERT" when read as ASCII).\\ \hline
4 & Float & $x$ coordinate of the 1st vertex.\\ \hline
8 & Float & $y$ coordinate of the 1st vertex.\\ \hline
12 & Float & $z$ coordinate of the 1st vertex.\\ \hline
16 & Float & $x$ coordinate of the 2nd vertex.\\ \hline
... & & \\ \hline
\end{tabular}

The length of the vertices section is $4(1+3N)$ bytes, where $N$ is the vertex
count.

\subsection{Normals}
The normals section is optional, and only present if the per-vertex normals
flag is set in the header.

The normals are stored as an integer identifier, 0x4d524f4e ("NORM"), followed
by all the normal coordinates. Each normal is stored as three floating point
values ($x,y,z$), and the number of normals is given by the "Vertex count" field
in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x4d524f4e, or "NORM" when read as ASCII).\\ \hline
4 & Float & $x$ coordinate of the 1st normal.\\ \hline
8 & Float & $y$ coordinate of the 1st normal.\\ \hline
12 & Float & $z$ coordinate of the 1st normal.\\ \hline
16 & Float & $x$ coordinate of the 2nd normal.\\ \hline
... & & \\ \hline
\end{tabular}

The length of the normals section is $4(1+3N)$ bytes, where $N$ is the vertex
count.

\subsection{UV map}
There can be zero or more UV maps. The number of UV maps is given by the
UV map count in the header.

Each UV map starts with an integer identifier, 0x43584554 ("TEXC"), followed
by two strings (the UV map name and the UV map file name reference), and
finally all the UV coordinates. Each UV coordinate is stored as two floating point
values ($u,v$), and the number of UV coordinates is given by the "Vertex count"
field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x43584554, or "TEXC" when read as ASCII).\\ \hline
4 & String & Unique UV map name ($p$ bytes long string).\\ \hline
$8+p$ & String & UV map file name reference ($q$ bytes long string).\\ \hline
$12+p+q$ & Float & $u$ coordinate of the 1st UV coordinate.\\ \hline
$16+p+q$ & Float & $v$ coordinate of the 1st UV coordinate.\\ \hline
$20+p+q$ & Float & $u$ coordinate of the 2nd UV coordinate.\\ \hline
... & & \\ \hline
\end{tabular}

The length of a UV map section is $4(3+2N)+p+q$ bytes, where $N$ is the vertex
count, $p$ is the name string length, and $q$ is the file name reference string
length.

\subsection{Attribute map}
There can be zero or more attribute maps. The number of attribute maps is given by the
attribute map count in the header.

Each attribute map starts with an integer identifier, 0x52545441 ("ATTR"), followed
by the attribute map name string, and finally all the attribute values. Each attribute
value is stored as four floating point values ($a,b,c,d$), and the number of
attribute values is given by the "Vertex count" field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x52545441, or "ATTR" when read as ASCII).\\ \hline
4 & String & Unique attribute map name ($p$ bytes long string).\\ \hline
$8+p$ & Float & $a$ component of the 1st attribute value.\\ \hline
$12+p$ & Float & $b$ component of the 1st attribute value.\\ \hline
$16+p$ & Float & $c$ component of the 1st attribute value.\\ \hline
$20+p$ & Float & $d$ component of the 1st attribute value.\\ \hline
$24+p$ & Float & $a$ component of the 2nd attribute value.\\ \hline
... & & \\ \hline
\end{tabular}

The length of an attribute map section is $4(2+4N)+p$ bytes, where $N$ is the vertex
count, and $p$ is the name string length.


\section{MG1}
To be written...

Please read the source code file compressMG1.c for more details on the body
format when the MG1 compression method is used.


\section{MG2}
To be written...

Please read the source code file compressMG2.c for more details on the body
format when the MG2 compression method is used.

\end{document}
