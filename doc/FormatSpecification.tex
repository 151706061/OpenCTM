%-------------------------------------------------------------------------------
% Document: OpenCTM Format Specification
% Author:   Marcus Geelnard
% Compile:  pdflatex FormatSpecification.tex
%-------------------------------------------------------------------------------
% Note: You need a LaTeX environment to build this document as PDF. The
% recommended way is to install TeX Live (http://www.tug.org/texlive/) and
% a decent LaTeX editor (e.g. texmaker, LEd, etc).
%
% Ubuntu:   sudo apt-get install texlive-full
% Mac OS X: http://www.tug.org/mactex/  (MacTeX.mpkg.zip)
%
% To build the PDF document, run pdflatex twice on this .tex file (in order to
% correctly build the TOC).
%-------------------------------------------------------------------------------

% Use the OpenCTM TeX style
\input{openctm-tex.sty}

% Document properties
\author{Marcus Geelnard}
\title{OpenCTM Format Specification}

% PDF specific document properties
\hypersetup{pdftitle={OpenCTM Format Specification}}
\hypersetup{pdfauthor={Marcus Geelnard}}
\hypersetup{pdfkeywords={OpenCTM,format,specification}}

% Document contents
\begin{document}

%--[ Title page ]---------------------------------------------------------------

\begin{titlepage}
\begin{center}
~
\vspace{5cm}

\includegraphics[width=10.0cm]{logo.pdf}
\vspace{0.4cm}

{\large File format version 5}

\vspace{1.0cm}

{\Large Format Specification}
\vspace{1.5cm}

Copyright \copyright \ 2009 Marcus Geelnard
\end{center}
\end{titlepage}


%--[ Table of contents ]--------------------------------------------------------

\tableofcontents


%-------------------------------------------------------------------------------

\chapter{Overview}
This document describes version 5 of the OpenCTM file format.

\section{File structure}
The structure of an OpenCTM file is as follows:

[Header]\newline
[Body data]

Each part of the file is described in the following chapters.

\section{Data formats}
All integer fields are stored in 32-bit little endian format (least significant
byte first).

All floating point fields are stored in 32-bit binary IEEE 754 format (little
endian).

All strings are stored as a 32-bit integer string length (number of bytes)
followed by a UTF-8 format string (there is no zero termination and no BOM).

\section{Packed data}
\label{tab:PackedData}
Some portions of the file are be packed by the lossless LZMA entropy coder,
and are encoded as follows:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} & \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Packed size (number of bytes, $p$).\\ \hline
4 & - & LZMA specific props (five bytes, required by the LZMA decoder).\\ \hline
9 & - & LZMA packed stream ($p$ bytes long).\\ \hline
\end{tabular}

The length of the unpacked data is always known from the context (e.g. the
triangle count uniquely defines the number of bytes required for the
uncompressed triangle indices array).

\subsection{Element interleaving}
Some packed data arrays use element level interleaving, meaning that the
data values are rearranged at the element level. For instance, in a data array
with three elements per value (stride = 3), $x$, $y$ and $z$, the elements are
rearranged as follows:

\begin{center}
$x_1,y_1,z_1,x_2,y_2,z_2,\ldots,x_N,y_N,z_N \Rightarrow 
x_1,x_2,\ldots,x_N,y_1,y_2,\ldots,y_N,z_1,z_2,\ldots,z_N$
\end{center}

When decompressing an array that uses element interleaving, the process is
reversed.

\subsection{Byte interleaving}
All packed data arrays use byte level interleaving, meaning that data values
are rearranged at the byte level. For instance, in an integer array, where each
element consists of four bytes: $a$, $b$, $c$ and $d$, the bytes are rearranged
as follows:

\begin{center}
$a_1,b_1,c_1,d_1,a_2,b_2,c_2,d_2,\ldots,a_N,b_N,c_N,d_N \Rightarrow 
a_1,a_2,\ldots,a_N,b_1,b_2,\ldots,b_N,c_1,c_2,\ldots,c_N,d_1,d_2,\ldots,d_N$
\end{center}

When decompressing an array that uses byte interleaving, the process is
reversed.

\subsection{Signed magnitude representation}
Some packed integer arrays use signed magnitude representation.

A signed magnitude value, $x'$, is converted to a two's complement value,
$x$, with the following method:

$x = \left\{\begin{array}{ll}
x'\; shr\; 1 & x'_0 = 0 \\
-((x'+1)\; shr\; 1) & x'_0 = 1
\end{array} \right.$

...where $x'_0$ is the least significant bit of $x'$.


%-------------------------------------------------------------------------------

\chapter{Header}
The file must start with a header, which looks as follows:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Magic identifier (0x4d54434f, or "OCTM" when read as ASCII).\\ \hline
4 & Integer & File format version (0x00000005 = version 5).\\ \hline
8 & Integer & Compression method, which must be one of the following:\\
 & & 0x00574152 - Use the RAW compression method.\\
 & & 0x0031474d - Use the MG1 compression method.\\
 & & 0x0032474d - Use the MG2 compression method.\\ \hline
12 & Integer & Vertex count.\\ \hline
16 & Integer & Triangle count.\\ \hline
20 & Integer & UV map count.\\ \hline
24 & Integer & Attribute map count.\\ \hline
28 & Integer & Boolean flags, or:ed together:\\
 & & 0x00000001 - The file contains per-vertex normals.\\ \hline
32 & String & File comment ($p$ bytes long string).\\ \hline
\end{tabular}

The length of the file header is $36+p$ bytes, where $p$ is the length of the
comment string.


%-------------------------------------------------------------------------------

\chapter{Body data}
The body data follows immediately after the file header. Its file offset is
dictated by the length of the file header.

The format of the body data is specific for each compression method, which is
defined by the "Compression method" field in the header.

The body data contains the vertex, index, normal, UV map and attribute map
data, usually in a compressed form.


\section{RAW}
The layout of the body data for the RAW compression method is:

[Indices]\newline
[Vertices]\newline
[Normals]\newline
[UV map 0]\newline
[UV map 1]\newline
...\newline
[UV map N]\newline
[Attribute map 0]\newline
[Attribute map 1]\newline
...\newline
[Attribute map M]

\subsection{Indices}
The indices are stored as an integer identifier, 0x58444e49 ("INDX"), followed
by all the triangle indices. Each index is an unsigned integer value. There are
three indices per triangle, and the number of triangles is given by the
"Triangle count" field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x58444e49, or "INDX" when read as ASCII).\\ \hline
4 & Integer & Vertex index for the 1st corner of the 1st triangle.\\ \hline
8 & Integer & Vertex index for the 2nd corner of the 1st triangle.\\ \hline
12 & Integer & Vertex index for the 3rd corner of the 1st triangle.\\ \hline
16 & Integer & Vertex index for the 1st corner of the 2nd triangle.\\ \hline
... & & \\ \hline
\end{tabular}

The length of the indices section is $4(1+3N)$ bytes, where $N$ is the triangle
count.

\subsection{Vertices}
The vertices are stored as an integer identifier, 0x54524556 ("VERT"), followed
by all the vertex coordinates. Each vertex coordinate is stored as three
floating point values ($x,y,z$), and the number of vertices is given by the
"Vertex count" field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x54524556, or "VERT" when read as ASCII).\\ \hline
4 & Float & $x$ coordinate of the 1st vertex.\\ \hline
8 & Float & $y$ coordinate of the 1st vertex.\\ \hline
12 & Float & $z$ coordinate of the 1st vertex.\\ \hline
16 & Float & $x$ coordinate of the 2nd vertex.\\ \hline
... & & \\ \hline
\end{tabular}

The length of the vertices section is $4(1+3N)$ bytes, where $N$ is the vertex
count.

\subsection{Normals}
The normals section is optional, and only present if the per-vertex normals
flag is set in the header.

The normals are stored as an integer identifier, 0x4d524f4e ("NORM"), followed
by all the normal coordinates. Each normal is stored as three floating point
values ($x,y,z$), and the number of normals is given by the "Vertex count" field
in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x4d524f4e, or "NORM" when read as ASCII).\\ \hline
4 & Float & $x$ coordinate of the 1st normal.\\ \hline
8 & Float & $y$ coordinate of the 1st normal.\\ \hline
12 & Float & $z$ coordinate of the 1st normal.\\ \hline
16 & Float & $x$ coordinate of the 2nd normal.\\ \hline
... & & \\ \hline
\end{tabular}

The length of the normals section is $4(1+3N)$ bytes, where $N$ is the vertex
count.

\subsection{UV maps}
There can be zero or more UV maps. The number of UV maps is given by the
UV map count in the header.

Each UV map starts with an integer identifier, 0x43584554 ("TEXC"), followed
by two strings (the UV map name and the UV map file name reference), and
finally all the UV coordinates. Each UV coordinate is stored as two floating point
values ($u,v$), and the number of UV coordinates is given by the "Vertex count"
field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x43584554, or "TEXC" when read as ASCII).\\ \hline
4 & String & Unique UV map name ($p$ bytes long string).\\ \hline
$8+p$ & String & UV map file name reference ($q$ bytes long string).\\ \hline
$12+p+q$ & Float & $u$ coordinate of the 1st UV coordinate.\\ \hline
$16+p+q$ & Float & $v$ coordinate of the 1st UV coordinate.\\ \hline
$20+p+q$ & Float & $u$ coordinate of the 2nd UV coordinate.\\ \hline
... & & \\ \hline
\end{tabular}

The length of a UV map section is $4(3+2N)+p+q$ bytes, where $N$ is the vertex
count, $p$ is the name string length, and $q$ is the file name reference string
length.

\subsection{Attribute maps}
There can be zero or more attribute maps. The number of attribute maps is given by the
attribute map count in the header.

Each attribute map starts with an integer identifier, 0x52545441 ("ATTR"), followed
by the attribute map name string, and finally all the attribute values. Each attribute
value is stored as four floating point values ($a,b,c,d$), and the number of
attribute values is given by the "Vertex count" field in the header:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x52545441, or "ATTR" when read as ASCII).\\ \hline
4 & String & Unique attribute map name ($p$ bytes long string).\\ \hline
$8+p$ & Float & $a$ component of the 1st attribute value.\\ \hline
$12+p$ & Float & $b$ component of the 1st attribute value.\\ \hline
$16+p$ & Float & $c$ component of the 1st attribute value.\\ \hline
$20+p$ & Float & $d$ component of the 1st attribute value.\\ \hline
$24+p$ & Float & $a$ component of the 2nd attribute value.\\ \hline
... & & \\ \hline
\end{tabular}

The length of an attribute map section is $4(2+4N)+p$ bytes, where $N$ is the vertex
count, and $p$ is the name string length.


\section{MG1}
The layout of the body data for the MG1 compression method is:

[Indices]\newline
[Vertices]\newline
[Normals]\newline
[UV map 0]\newline
[UV map 1]\newline
...\newline
[UV map N]\newline
[Attribute map 0]\newline
[Attribute map 1]\newline
...\newline
[Attribute map M]

\subsection{Indices}
The triangle indices are stored as an integer identifier, 0x58444e49 ("INDX"),
followed by a packed integer array with element interleaving (see
\ref{tab:PackedData}).

The unpacked indices array contains delta-encoded indices:

$i'_1, j'_1, k'_1, i'_2, j'_2, k'_2, ...$

...that translate into the original triangle indices with the following method:

$i_m = i'_m + i'_{m-1}$

$j_m = \left\{\begin{array}{ll}
j'_m + j'_{m-1}  & i'_m = i'_{m-1} \\
j'_m + i'_m & i'_m \neq i'_{m-1}
\end{array} \right.$

$k_m = k'_m + i'_m$

...where $i_m, j_m$ and $k_m$ are the 1:st, 2:nd and 3:rd vertex index of the
m:th triangle, respectively.

Please note that the indices should be sorted in such a manner that $i'_m, j'_m$
and $k'_m$ are always positive.

\subsection{Vertices}
The vertices are stored as an integer identifier, 0x54524556 ("VERT"), followed
by a packed float array without element interleaving (see \ref{tab:PackedData}).

The unpacked vertex array is stored as in the RAW format ($x, y, z$).

\subsection{Normals}
The normals section is optional, and only present if the per-vertex normals
flag is set in the header.

The normals are stored as an integer identifier, 0x4d524f4e ("NORM"), followed
by a packed float array with element interleaving (see \ref{tab:PackedData}).

The unpacked normal array is stored as in the RAW format ($x, y, z$).

\subsection{UV maps}
There can be zero or more UV maps. The number of UV maps is given by the
UV map count in the header.

Each UV map starts with an integer identifier, 0x43584554 ("TEXC"), followed
by two strings (the UV map name and the UV map file name reference), and
finally the packed UV coordinate data.

The UV coordinate data is a packed float array with element interleaving
(see \ref{tab:PackedData}).

The unpacked UV coordinate array is stored as in the RAW format ($u, v$).

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x43584554, or "TEXC" when read as ASCII).\\ \hline
4 & String & Unique UV map name ($p$ bytes long string).\\ \hline
$8+p$ & String & UV map file name reference ($q$ bytes long string).\\ \hline
$12+p+q$ & - & Packed UV coordinate data.\\ \hline
\end{tabular}

...where $p$ is the name string length, and $q$ is the file name reference string
length.

\subsection{Attribute maps}
There can be zero or more attribute maps. The number of attribute maps is given by the
attribute map count in the header.

Each attribute map starts with an integer identifier, 0x52545441 ("ATTR"), followed
by the attribute map name string, and finally the packed attribute values.

The attribute value data is a packed float array with element interleaving
(see \ref{tab:PackedData}).

The unpacked attribute value array is stored as in the RAW format ($a, b, c, d$).

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x52545441, or "ATTR" when read as ASCII).\\ \hline
4 & String & Unique attribute map name ($p$ bytes long string).\\ \hline
$8+p$ & - & Packed attribute value data.\\ \hline
\end{tabular}

...where $p$ is the name string length.


\section{MG2}
The layout of the body data for the MG2 compression method is:

[MG2 header]\newline
[Vertices]\newline
[Grid indices]\newline
[Indices]\newline
[Normals]\newline
[UV map 0]\newline
[UV map 1]\newline
...\newline
[UV map N]\newline
[Attribute map 0]\newline
[Attribute map 1]\newline
...\newline
[Attribute map M]

\subsection{MG2 vertex coordinate coding}
In the MG2 compression method, all the vertices are divided into a 3D grid,
which can be described by an axis aligned bounding box (minimum fit to the
vertices), and the division factors along the $x$, $y$ and $z$ axes, as shown
in figure \ref{fig:Grid}.

\begin{figure}
\includegraphics[width=10.0cm]{grid.pdf}
\caption{3D space subdivision grid. $LB$ and $HB$ are the lower and higher bounds
of the axis aligned bounding box. $div_x$, $div_y$ and $div_z$ are the number
of divisions along each of the axes.}
\label{fig:Grid}
\end{figure}

The vertices are all coded relative to the grid origin of the grid box to which
they belong, and all vertices are associated with a grid box with a unique
grid index.

The grid index, $gi$, is encoded as:

$gi = g_x + div_x(g_y + div_y \times g_z)$

...where $g_x$, $g_y$ and $g_z$ are the $x$, $y$ and $z$ positions of the grid
box, within the grid.

\subsection{MG2 header}
The MG2 header contains information about how to interpret the mesh data. The
header looks as follows:

\begin{tabular}{|l|l|l|}\hline
\textbf{Offset} &  \textbf{Type} & \textbf{Description}\\ \hline
0 & Integer & Identifier (0x4832474d, or "MG2H" when read as ASCII).\\ \hline
4 & Float & Vertex precision.\\ \hline
8 & Float & Normal precision.\\ \hline
12 & Float & X coordinate of the lower bound of the mesh bounding box.\\ \hline
16 & Float & Y coordinate of the lower bound of the mesh bounding box.\\ \hline
20 & Float & Z coordinate of the lower bound of the mesh bounding box.\\ \hline
24 & Float & X coordinate of the higher bound of the mesh bounding box.\\ \hline
28 & Float & Y coordinate of the higher bound of the mesh bounding box.\\ \hline
32 & Float & Z coordinate of the higher bound of the mesh bounding box.\\ \hline
36 & Integer & Number of grid divisions along the X axis (min 1).\\ \hline
40 & Integer & Number of grid divisions along the Y axis (min 1).\\ \hline
44 & Integer & Number of grid divisions along the Z axis (min 1).\\ \hline
\end{tabular}


\subsection{Vertices}
To be written...

\subsection{Grid indices}
To be written...

\subsection{Indices}
To be written...

\subsection{Normals}
To be written...

\subsection{UV maps}
To be written...

\subsection{Attribute maps}
To be written...

\end{document}
