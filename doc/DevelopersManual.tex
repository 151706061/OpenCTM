%-------------------------------------------------------------------------------
% Document: OpenCTM Developers Manual
% Author:   Marcus Geelnard
% Compile:  pdflatex DevelopersManual.tex
%-------------------------------------------------------------------------------
% Note: You need a LaTeX environment to build this document as PDF. The
% recommended way is to install TeX Live (http://www.tug.org/texlive/) and
% a decent LaTeX editor (e.g. texmaker, LEd, etc).
%
% Ubuntu: sudo apt-get install texlive-full
%
% To build the PDF document, run pdflatex twice on this .tex file (in order to
% correctly build the TOC).
%-------------------------------------------------------------------------------

% Use the OpenCTM TeX style
\input{openctm-tex.sty}

% Document properties
\author{Marcus Geelnard}
\title{OpenCTM Developers Manual}

% Document contents
\begin{document}

%--[ Title pages ]--------------------------------------------------------------

\maketitle

\tableofcontents


%-------------------------------------------------------------------------------

\chapter{Introduction}
The OpenCTM file format is an open format for storing 3D triangle meshes.
One of the main advantages over other similar file formats is its ability
to losslessly compress the triangle geometry to a fraction of the corresponding
raw data size.

This document describes how to use the OpenCTM API to load and save OpenCTM
format files. It is mostly written for C/C++ users, but should be useful for
other programming languages too, since the concepts and function calls are
virtually identical regardless of programming language.


%-------------------------------------------------------------------------------

\chapter{Concepts}

\section{The OpenCTM API}
The OpenCTM API makes it easy to read and write OpenCTM format files. The API is
implemented in the form of a software library that an application can be linked
to in order to access the OpenCTM API.

The software library itself is written in standard, portable C language, but
can be used from many other programming languages (writing language bindings
for new languages should be fairly straight forward, since the API was written
with cross-language portability in mind).

The full documentation of the OpenCTM API can be found in the Doxygen-generated
documentation ("API Reference"), which describes all API functions, types,
constants etc.


\section{The triangle mesh}
The triangle mesh, in OpenCTM terms, is managed in a format that is well suited
for a modern 3D rendering pipeline, such as OpenGL.

At a glance, the OpenCTM mesh has the following properties:

\begin{itemize}
    \item A vertex is a set of attributes that uniquely identify the vertex.
          This includes: vertex coordinate, normal, texture coordinate(s) and
          custom vertex attrubite(s) (such as color, weight, etc).
    \item A triangle is described by three vertex indices.
    \item In the OpenCTM API, these mesh data are treated as arrays (an integer
          array for the triangle indices, and floating point arrays for the
          vertex data).
    \item All vertex data arrays in a mesh must have the same number of elements
          (for instance, there is exactly one normal associated with each
          vertex coordinate).
    \item All mesh data are optional, except for the triangle indices and the
          vertex coordinates. For instance, it is possible to leave out the
          normal information.
\end{itemize}

For an example of the mesh data structure see table \ref{tab:MeshVert} (vertex
data) and table \ref{tab:MeshTri} (triangle data).

\begin{table}[p]
\centering
\begin{tabular}{|l|l|l|l|l|l|l|l|}\hline
\textbf{Index} & 0 & 1 & 2 & 3 & 4 & \textellipsis & N\\ \hline
\textbf{Vertex} & $v_0$ & $v_1$ & $v_2$ & $v_3$ & $v_4$ & \textellipsis & $v_N$\\ \hline
\textbf{Normal} & $n_0$ & $n_1$ & $n_2$ & $n_3$ & $n_4$ & \textellipsis & $n_N$\\ \hline
\textbf{TexCoord1} & $t1_0$ & $t1_1$ & $t1_2$ & $t1_3$ & $t1_4$ & \textellipsis & $t1_N$\\ \hline
\textbf{TexCoord2} & $t2_0$ & $t2_1$ & $t2_2$ & $t2_3$ & $t2_4$ & \textellipsis & $t2_N$\\ \hline
\textbf{Attrib1} & $a1_0$ & $a1_1$ & $a1_2$ & $a1_3$ & $a1_4$ & \textellipsis & $a1_N$\\ \hline
\textbf{Attrib2} & $a2_0$ & $a2_1$ & $a2_2$ & $a2_3$ & $a2_4$ & \textellipsis & $a2_N$\\ \hline
\end{tabular}
\caption{Mesh vertex data structure in OpenCTM, for a mesh with normals,
two texture coordinates per vertex, and two custom attributes per vertex.}
\label{tab:MeshVert}
\end{table}

\begin{table}[p]
\centering
\begin{tabular}{|l|l|l|l|l|l|l|l|}\hline
\textbf{Triangle} & $tri_0$ & $tri_1$ & $tri_2$ & $tri_3$ & $tri_4$ & \textellipsis & $tri_M$\\ \hline
\end{tabular}
\caption{Mesh triangle data structure in OpenCTM, where $tri_k$ is a tuple of
three vertex indices. For instance,
$tri_0=(0, 1, 2)$,
$tri_1=(0, 2, 3)$,
$tri_2=(3, 5, 4)$, \textellipsis}
\label{tab:MeshTri}
\end{table}


\subsection{Triangle indices}
\label{sec:MeshIndices}

Each triangle is described by three integers: one vertex index for each corner
of the triangle). The triangle index array looks like this:

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|}\hline
$tri^0_0$ & $tri^1_0$ & $tri^2_0$ & $tri^0_1$ & $tri^1_1$ & $tri^2_1$ & \textellipsis & $tri^0_M$ & $tri^1_M$ & $tri^2_M$\\ \hline
\end{tabular}

\textellipsis where $tri^j_k$ is the vertex index for the $j$:th corner of the
$k$:th triangle.

It is recommended (but not required) that:
\begin{itemize}
    \item \textellipsis given the three coordinates of a triangle,
          $p_1, p_2, p_3$, the front/out direction of the triangle (the "flat
          normal") should be defined by the normalized cross product:
          $(p_2-p_1)\times (p_3-p_1)$.
\end{itemize}


\subsection{Vertex coordinates}

Each vertex coordinate is described by three floating point values: $x$, $y$
and $z$. The vertex coordinate array looks like this:

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}\hline
$x_0$ & $y_0$ & $z_0$ & $x_1$ & $y_1$ & $z_1$ & \textellipsis & $x_N$ & $y_N$ & $z_N$\\ \hline
\end{tabular}

\textellipsis where $x_k$, $y_k$ and $z_k$ are the $x$, $y$ and $z$ coordinates
of the $k$:th vertex.

It is recommended (but not required) that:
\begin{itemize}
    \item \textellipsis the "up" direction of all vertex coordinates is the
          positive $z$-axis.
    \item \textellipsis the unit of all vertex coordinates is meters ($m$).
\end{itemize}


\subsection{Normals}

Each normal is described by three floating point values: $x$, $y$
and $z$. The normal array looks like this:

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}\hline
$x_0$ & $y_0$ & $z_0$ & $x_1$ & $y_1$ & $z_1$ & \textellipsis & $x_N$ & $y_N$ & $z_N$\\ \hline
\end{tabular}

\textellipsis where $x_k$, $y_k$ and $z_k$ are the $x$, $y$ and $z$ components
of the $k$:th normal.

It is recommended (but not required) that:
\begin{itemize}
    \item \textellipsis all normals have unit lengths (i.e.
          $x_k^2+y_k^2+z_k^2=1\:\forall\:k$).
    \item \textellipsis the vertex normal points in the "out" direction of the
          surface, as defined by the flat normals of the neighbouring triangles
          (see \ref{sec:MeshIndices}).
\end{itemize}


\subsection{Texture coordinates}

A mesh may have several texture maps, where each texture map is described by:

\begin{itemize}
    \item A texture coordinate array.
    \item A unique texture map name.
    \item An file name reference (optional).
\end{itemize}

Each texture coordinate is described by two floating point values: $u$ and $v$.
A texture coordinate array looks like this:

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|}\hline
$u_0$ & $v_0$ & $u_1$ & $v_1$ & $u_2$ & $v_2$ & \textellipsis & $u_N$ & $v_N$\\ \hline
\end{tabular}

\textellipsis where $u_k$ and $v_k$ are the $u$ and $v$ components
of the $k$:th texture coordinate.

$(u=0, v=0)$ represents the lower left corner of the texture, and $(u=1, v=1)$
represents the upper right corner of the texture.

It is recommended (but not required) that:
\begin{itemize}
    \item \textellipsis the texture coordinates are in the range $[0,1]$.
\end{itemize}


\subsection{Custom vertex attributes}

A mesh may have several custom vertex attribute maps, where each attribute map
is described by:

\begin{itemize}
    \item A vertex attribute array.
    \item A unique attribute map name.
\end{itemize}

Each vertex attribute is described by four floating point values: $a$, $b$, $c$
and $d$. An attribute array looks like this:

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}\hline
$a_0$ & $b_0$ & $c_0$ & $d_0$ & $a_1$ & $b_1$ & $c_1$ & $d_1$ & \textellipsis & $a_N$ & $b_N$ & $c_N$ & $d_N$\\ \hline
\end{tabular}

\textellipsis where $a_k$, $b_k$, $c_k$ and $d_k$ are the four attribute values
of the $k$:th attribute.

It is recommended (but not required) that:
\begin{itemize}
    \item \textellipsis the value range of clamped attributes, such as color
          or percentage attributes, is $[0,1]$.
    \item \textellipsis unused components are set to either zero or one,
          depending on the context.
    \item \textellipsis the attribute map name is a descriptive name of the
          attribute.
\end{itemize}

The following attribute names and formats should be used whenever possible to
represent specific information (please note that names are case sensitive):

\begin{tabular}{|l|l|l|l|}\hline
\textbf{Name} & \textbf{Format $(a,b,c,d)$} & \textbf{Range} & \textbf{Description}\\ \hline
Color & $(R,G,B,A)$ & $[0,1]$ & Color and alpha (opacity).\\ \hline
Weight & $(W,0,0,0)$ & $[0,1]$ & Weight factor.\\ \hline
\end{tabular}


\section{The OpenCTM context}
TBD



%-------------------------------------------------------------------------------

\chapter{Usage}

\section{Prerequisites}
To use the OpenCTM API, you need to include the OpenCTM include file, like this:

\begin{lstlisting}
#include <openctm.h>
\end{lstlisting}

You also need to link with the OpenCTM import library. For instance, in MS
Visual Studio you can add "openctm.lib" to your Additional Dependencies field
in the Linker section. For gcc/g++ or similar compilers, you will typically
add -lopenctm to the list of compiler options, for instance:

\begin{lstlisting}
> g++ -o foo foo.cpp -lopenctm
\end{lstlisting}


\section{Loading OpenCTM files}
Below is a minimal example of how to load an OpenCTM file with the OpenCTM API,
in just a few lines of code:

\begin{lstlisting}
CTMcontext context;
CTMuint vertCount, triCount, * indices;
CTMfloat * vertices;

// Create a new context
context = ctmNewContext(CTM_IMPORT);

// Load the OpenCTM file
ctmLoad(context, "mymesh.ctm");
if(ctmGetError(context) == CTM_NONE)
{
  // Access the mesh data
  vertCount = ctmGetInteger(context, CTM_VERTEX_COUNT);
  vertices = ctmGetFloatArray(context, CTM_VERTICES);
  triCount = ctmGetInteger(context, CTM_TRIANGLE_COUNT);
  indices = ctmGetIntegerArray(context, CTM_INDICES);

  // Deal with the mesh (e.g. transcode it to our
  // internal representation)
  // ...
}

// Free the context (this frees all memory allocated by
// the OpenCTM context)
ctmFreeContext(context);
\end{lstlisting}



%-------------------------------------------------------------------------------

\chapter{C++ extensions}
To take better advantage of some of the C++ language features, such as
exception handling, a few C++ wrapper classes is availbale through the standard
API when compiling a C++ program. As usual, just include "openctm.h", and you
will have access to two C++ classes: CTMimporer and CTMexporter.

The main differences between the C++ classes and the standard API are:

\begin{itemize}
    \item The C++ classes call ctmNewContext() and ctmFreeContext() in their
          constructors and destructors respectively, which makes it easier to
          use the C++ dynamic scope mechanisms (such as exception handling).
    \item Whenever an OpenCTM error occurs, an exception is thrown. Hence, there
          is no method corresponding to the ctmGetError() function.
\end{itemize}

\section{The CTMimporter class}

Here is an example of how to use the CTMimporter class in C++:

\begin{lstlisting}
try
{
  // Create a new OpenCTM importer object
  CTMimporter ctm;

  // Load the OpenCTM file
  ctm.Load("mymesh.ctm");

  // Access the mesh data
  CTMuint vertCount = ctm.GetInteger(CTM_VERTEX_COUNT);
  CTMfloat * vertices = ctm.GetFloatArray(CTM_VERTICES);
  CTMuint triCount = ctm.GetInteger(CTM_TRIANGLE_COUNT);
  CTMuint * indices = ctm.GetIntegerArray(CTM_INDICES);

  // Deal with the mesh (e.g. transcode it to our
  // internal representation)
  // ...
}
catch(exception &e)
{
  cout << "Error: " << e.what() << endl;
}
\end{lstlisting}


\section{The CTMexporter class}
TBD


\end{document}
